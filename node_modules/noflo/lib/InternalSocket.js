(function() {
  var EventEmitter, IP, InternalSocket,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  IP = require('./IP');

  InternalSocket = (function(_super) {
    __extends(InternalSocket, _super);

    InternalSocket.prototype.regularEmitEvent = function(event, data) {
      return this.emit(event, data);
    };

    InternalSocket.prototype.debugEmitEvent = function(event, data) {
      var error;
      try {
        return this.emit(event, data);
      } catch (_error) {
        error = _error;
        if (error.id && error.metadata && error.error) {
          if (this.listeners('error').length === 0) {
            throw error.error;
          }
          this.emit('error', error);
          return;
        }
        if (this.listeners('error').length === 0) {
          throw error;
        }
        return this.emit('error', {
          id: this.to.process.id,
          error: error,
          metadata: this.metadata
        });
      }
    };

    function InternalSocket(metadata) {
      this.metadata = metadata != null ? metadata : {};
      this.brackets = [];
      this.dataDelegate = null;
      this.debug = false;
      this.emitEvent = this.regularEmitEvent;
    }

    InternalSocket.prototype.connect = function() {
      return this.handleSocketEvent('connect', null);
    };

    InternalSocket.prototype.disconnect = function() {
      return this.handleSocketEvent('disconnect', null);
    };

    InternalSocket.prototype.isConnected = function() {
      return this.brackets.length > 0;
    };

    InternalSocket.prototype.send = function(data) {
      if (data === void 0 && typeof this.dataDelegate === 'function') {
        data = this.dataDelegate();
      }
      return this.handleSocketEvent('data', data);
    };

    InternalSocket.prototype.post = function(data) {
      if (data === void 0 && typeof this.dataDelegate === 'function') {
        data = this.dataDelegate();
      }
      if (data.type === 'data' && this.brackets.length === 0) {
        this.emitEvent('connect', this);
      }
      this.handleSocketEvent('data', data, false);
      if (data.type === 'data' && this.brackets.length === 0) {
        return this.emitEvent('disconnect', this);
      }
    };

    InternalSocket.prototype.beginGroup = function(group) {
      return this.handleSocketEvent('begingroup', group);
    };

    InternalSocket.prototype.endGroup = function() {
      return this.handleSocketEvent('endgroup');
    };

    InternalSocket.prototype.setDataDelegate = function(delegate) {
      if (typeof delegate !== 'function') {
        throw Error('A data delegate must be a function.');
      }
      return this.dataDelegate = delegate;
    };

    InternalSocket.prototype.setDebug = function(active) {
      this.debug = active;
      return this.emitEvent = this.debug ? this.debugEmitEvent : this.regularEmitEvent;
    };

    InternalSocket.prototype.getId = function() {
      var fromStr, toStr;
      fromStr = function(from) {
        return "" + from.process.id + "() " + (from.port.toUpperCase());
      };
      toStr = function(to) {
        return "" + (to.port.toUpperCase()) + " " + to.process.id + "()";
      };
      if (!(this.from || this.to)) {
        return "UNDEFINED";
      }
      if (this.from && !this.to) {
        return "" + (fromStr(this.from)) + " -> ANON";
      }
      if (!this.from) {
        return "DATA -> " + (toStr(this.to));
      }
      return "" + (fromStr(this.from)) + " -> " + (toStr(this.to));
    };

    InternalSocket.prototype.legacyToIp = function(event, payload) {
      if (IP.isIP(payload)) {
        return payload;
      }
      switch (event) {
        case 'connect':
        case 'begingroup':
          return new IP('openBracket', payload);
        case 'disconnect':
        case 'endgroup':
          return new IP('closeBracket');
        default:
          return new IP('data', payload);
      }
    };

    InternalSocket.prototype.ipToLegacy = function(ip) {
      var legacy;
      switch (ip.type) {
        case 'openBracket':
          if (this.brackets.length === 1) {
            return legacy = {
              event: 'connect',
              payload: this
            };
          }
          return legacy = {
            event: 'begingroup',
            payload: ip.data
          };
        case 'data':
          return legacy = {
            event: 'data',
            payload: ip.data
          };
        case 'closeBracket':
          if (this.brackets.length === 0) {
            return legacy = {
              event: 'disconnect',
              payload: this
            };
          }
          return legacy = {
            event: 'endgroup',
            payload: ip.data
          };
      }
    };

    InternalSocket.prototype.handleSocketEvent = function(event, payload, autoConnect) {
      var ip, legacyEvent;
      if (autoConnect == null) {
        autoConnect = true;
      }
      ip = this.legacyToIp(event, payload);
      if (ip.type === 'data' && this.brackets.length === 0 && autoConnect) {
        this.handleSocketEvent('connect', null);
      }
      if (ip.type === 'openBracket') {
        if (ip.data === null) {
          if (this.brackets.length) {
            return;
          }
        } else {
          if (this.brackets.length === 0 && autoConnect) {
            this.handleSocketEvent('connect', null);
          }
        }
        this.brackets.push(ip.data);
      }
      if (ip.type === 'closeBracket') {
        if (this.brackets.length === 0) {
          return;
        }
        ip.data = this.brackets.pop();
      }
      this.emitEvent('ip', ip);
      if (!(ip && ip.type)) {
        return;
      }
      legacyEvent = this.ipToLegacy(ip);
      return this.emitEvent(legacyEvent.event, legacyEvent.payload);
    };

    return InternalSocket;

  })(EventEmitter);

  exports.InternalSocket = InternalSocket;

  exports.createSocket = function() {
    return new InternalSocket;
  };

}).call(this);
