var chai, noflo;

if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
  if (!chai) {
    chai = require('chai');
  }
  noflo = require('../src/lib/NoFlo.coffee');
} else {
  noflo = require('noflo');
}

describe('Component', function() {
  describe('with required ports', function() {
    it('should throw an error upon sending packet to an unattached required port', function() {
      var c, s2;
      s2 = new noflo.internalSocket.InternalSocket;
      c = new noflo.Component({
        outPorts: {
          required_port: {
            required: true
          },
          optional_port: {}
        }
      });
      c.outPorts.optional_port.attach(s2);
      return chai.expect(function() {
        return c.outPorts.required_port.send('foo');
      }).to["throw"]();
    });
    return it('should be cool with an attached port', function() {
      var c, f, s1, s2;
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      c = new noflo.Component({
        inPorts: {
          required_port: {
            required: true
          },
          optional_port: {}
        }
      });
      c.inPorts.required_port.attach(s1);
      c.inPorts.optional_port.attach(s2);
      f = function() {
        s1.send('some-more-data');
        return s2.send('some-data');
      };
      return chai.expect(f).to.not["throw"]();
    });
  });
  describe('with component creation shorthand', function() {
    it('should make component creation easy', function(done) {
      var c, s1, s2;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              return chai.expect(component).to.equal(c);
            }
          },
          just_processor: function(event, packet, component) {
            if (event !== 'data') {
              return;
            }
            chai.expect(packet).to.equal('some-data');
            chai.expect(component).to.equal(c);
            return done();
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      s2 = new noflo.internalSocket.InternalSocket;
      c.inPorts.just_processor.attach(s1);
      c.inPorts.just_processor.nodeInstance = c;
      s1.send('some-data');
      return s2.send('some-data');
    });
    it('should throw errors if there is no error port', function(done) {
      var c, s1;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              chai.expect(function() {
                return c.error(new Error);
              }).to["throw"](Error);
              return done();
            }
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    it('should throw errors if there is a non-attached error port', function(done) {
      var c, s1;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              chai.expect(function() {
                return c.error(new Error);
              }).to["throw"](Error);
              return done();
            }
          }
        },
        outPorts: {
          error: {
            datatype: 'object',
            required: true
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    it('should not throw errors if there is a non-required error port', function(done) {
      var c, s1;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              c.error(new Error);
              return done();
            }
          }
        },
        outPorts: {
          error: {
            required: false
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    return it('should send errors if there is a connected error port', function(done) {
      var c, groups, grps, s1, s2;
      grps = [];
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event === 'begingroup') {
                grps.push(packet);
              }
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              return c.error(new Error, grps);
            }
          }
        },
        outPorts: {
          error: {
            datatype: 'object'
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      groups = ['foo', 'bar'];
      s2.on('begingroup', function(grp) {
        return chai.expect(grp).to.equal(groups.shift());
      });
      s2.on('data', function(err) {
        chai.expect(err).to.be.an.instanceOf(Error);
        chai.expect(groups.length).to.equal(0);
        return done();
      });
      c.inPorts["in"].attach(s1);
      c.outPorts.error.attach(s2);
      c.inPorts["in"].nodeInstance = c;
      s1.beginGroup('foo');
      s1.beginGroup('bar');
      return s1.send('some-data');
    });
  });
  describe('defining ports with invalid names', function() {
    it('should throw an error with uppercase letters in inport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new noflo.Component({
          inPorts: {
            fooPort: {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
    it('should throw an error with uppercase letters in outport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new noflo.Component({
          outPorts: {
            BarPort: {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
    return it('should throw an error with special characters in inport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new noflo.Component({
          inPorts: {
            '$%^&*a': {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
  });
  describe('starting a component', function() {
    return it('should flag the component as started', function() {
      var c, i;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        }
      });
      i = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(i);
      c.start();
      chai.expect(c.started).to.equal(true);
      return chai.expect(c.isStarted()).to.equal(true);
    });
  });
  describe('shutting down a component', function() {
    return it('should flag the component as not started', function() {
      var c, i;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        }
      });
      i = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(i);
      c.start();
      c.shutdown();
      chai.expect(c.started).to.equal(false);
      return chai.expect(c.isStarted()).to.equal(false);
    });
  });
  describe('with object-based IPs', function() {
    it('should speak IP objects', function(done) {
      var c, s1, s2;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            handle: function(ip, component) {
              chai.expect(ip).to.be.an('object');
              chai.expect(ip.type).to.equal('data');
              chai.expect(ip.groups).to.be.an('array');
              chai.expect(ip.groups).to.eql(['foo']);
              chai.expect(ip.data).to.be.a('string');
              chai.expect(ip.data).to.equal('some-data');
              return c.outPorts.out.data('bar', {
                groups: ['foo']
              });
            }
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      s2.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.groups).to.be.an('array');
        chai.expect(ip.groups).to.eql(['foo']);
        chai.expect(ip.data).to.be.a('string');
        chai.expect(ip.data).to.equal('bar');
        return done();
      });
      c.inPorts["in"].attach(s1);
      c.outPorts.out.attach(s2);
      return s1.post(new noflo.IP('data', 'some-data', {
        groups: ['foo']
      }));
    });
    return it('should support substreams', function(done) {
      var c, d, s1, s2, s3;
      c = new noflo.Component({
        inPorts: {
          tags: {
            datatype: 'string',
            handle: function(ip) {
              chai.expect(ip).to.be.an('object');
              switch (ip.type) {
                case 'openBracket':
                  c.str += "<" + ip.data + ">";
                  return c.level++;
                case 'data':
                  return c.str += ip.data;
                case 'closeBracket':
                  c.str += "</" + ip.data + ">";
                  c.level--;
                  if (c.level === 0) {
                    c.outPorts.html.data(c.str);
                    return c.str = '';
                  }
              }
            }
          }
        },
        outPorts: {
          html: {
            datatype: 'string'
          }
        }
      });
      c.str = '';
      c.level = 0;
      d = new noflo.Component({
        inPorts: {
          bang: {
            datatype: 'bang',
            handle: function(ip) {
              return d.outPorts.tags.openBracket('p').openBracket('em').data('Hello').closeBracket('em').data(', ').openBracket('strong').data('World!').closeBracket('strong').closeBracket('p');
            }
          }
        },
        outPorts: {
          tags: {
            datatype: 'string'
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      s3 = new noflo.internalSocket.InternalSocket;
      s3.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('<p><em>Hello</em>, <strong>World!</strong></p>');
        return done();
      });
      d.inPorts.bang.attach(s1);
      d.outPorts.tags.attach(s2);
      c.inPorts.tags.attach(s2);
      c.outPorts.html.attach(s3);
      return s1.post(new noflo.IP('data', 'start'));
    });
  });
  return describe('with process function', function() {
    var c, sin1, sin2, sin3, sout1, sout2;
    c = null;
    sin1 = null;
    sin2 = null;
    sin3 = null;
    sout1 = null;
    sout2 = null;
    beforeEach(function(done) {
      sin1 = new noflo.internalSocket.InternalSocket;
      sin2 = new noflo.internalSocket.InternalSocket;
      sin3 = new noflo.internalSocket.InternalSocket;
      sout1 = new noflo.internalSocket.InternalSocket;
      sout2 = new noflo.internalSocket.InternalSocket;
      return done();
    });
    it('should trigger on IPs', function(done) {
      var count, hadIPs;
      hadIPs = [];
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'boolean'
          }
        },
        process: function(input, output) {
          hadIPs = [];
          if (input.has('foo')) {
            hadIPs.push('foo');
          }
          if (input.has('bar')) {
            hadIPs.push('bar');
          }
          return output.sendDone({
            baz: true
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      count = 0;
      sout1.on('ip', function(ip) {
        count++;
        if (count === 1) {
          chai.expect(hadIPs).to.eql(['foo']);
        }
        if (count === 2) {
          chai.expect(hadIPs).to.eql(['foo', 'bar']);
          return done();
        }
      });
      sin1.post(new noflo.IP('data', 'first'));
      return sin2.post(new noflo.IP('data', 'second'));
    });
    it('should not be triggered by non-triggering ports', function(done) {
      var count, triggered;
      triggered = [];
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string',
            triggering: false
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'boolean'
          }
        },
        process: function(input, output) {
          triggered.push(input.port.name);
          return output.sendDone({
            baz: true
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      count = 0;
      sout1.on('ip', function(ip) {
        count++;
        if (count === 1) {
          chai.expect(triggered).to.eql(['bar']);
        }
        if (count === 2) {
          chai.expect(triggered).to.eql(['bar', 'bar']);
          return done();
        }
      });
      sin1.post(new noflo.IP('data', 'first'));
      sin2.post(new noflo.IP('data', 'second'));
      sin1.post(new noflo.IP('data', 'first'));
      return sin2.post(new noflo.IP('data', 'second'));
    });
    it('should fetch undefined for premature data', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'boolean',
            triggering: false,
            control: true
          },
          baz: {
            datatype: 'string',
            triggering: false,
            control: true
          }
        },
        process: function(input, output) {
          var bar, baz, foo, _ref;
          if (!input.has('foo')) {
            return;
          }
          _ref = input.getData('foo', 'bar', 'baz'), foo = _ref[0], bar = _ref[1], baz = _ref[2];
          chai.expect(foo).to.be.a('string');
          chai.expect(bar).to.be.undefined;
          chai.expect(baz).to.be.undefined;
          return done();
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.inPorts.baz.attach(sin3);
      sin1.post(new noflo.IP('data', 'AZ'));
      sin2.post(new noflo.IP('data', true));
      return sin3.post(new noflo.IP('data', 'first'));
    });
    it('should receive and send complete noflo.IP objects', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, _ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          _ref = input.get('foo', 'bar'), foo = _ref[0], bar = _ref[1];
          baz = {
            foo: foo.data,
            bar: bar.data,
            groups: foo.groups,
            type: bar.type
          };
          return output.sendDone({
            baz: new noflo.IP('data', baz, {
              groups: ['baz']
            })
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        chai.expect(ip.data.groups).to.eql(['foo']);
        chai.expect(ip.data.type).to.equal('data');
        chai.expect(ip.groups).to.eql(['baz']);
        return done();
      });
      sin1.post(new noflo.IP('data', 'foo', {
        groups: ['foo']
      }));
      return sin2.post(new noflo.IP('data', 'bar', {
        groups: ['bar']
      }));
    });
    it('should receive and send just IP data if wanted', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, _ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          _ref = input.getData('foo', 'bar'), foo = _ref[0], bar = _ref[1];
          baz = {
            foo: foo,
            bar: bar
          };
          return output.sendDone({
            baz: baz
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        return done();
      });
      sin1.post(new noflo.IP('data', 'foo', {
        groups: ['foo']
      }));
      return sin2.post(new noflo.IP('data', 'bar', {
        groups: ['bar']
      }));
    });
    it('should receive IPs and be able to selectively find them', function(done) {
      var called, shouldHaveSent;
      called = 0;
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, foo, validate;
          validate = function(ip) {
            called++;
            return ip.type === 'data' && ip.data === 'hello';
          };
          if (!input.has('foo', 'bar', validate)) {
            return;
          }
          foo = input.get('foo');
          while ((foo != null ? foo.type : void 0) !== 'data') {
            foo = input.get('foo');
          }
          bar = input.getData('bar');
          return output.sendDone({
            baz: "" + foo.data + ":" + bar
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      shouldHaveSent = false;
      sout1.on('ip', function(ip) {
        chai.expect(shouldHaveSent, 'Should not sent before its time').to.equal(true);
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('hello:hello');
        chai.expect(called).to.equal(10);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('data', 'hello', sin1.post(new noflo.IP('closeBracket', 'a'))));
      shouldHaveSent = true;
      return sin2.post(new noflo.IP('data', 'hello'));
    });
    it('should keep last value for controls', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string',
            control: true
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, _ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          _ref = input.getData('foo', 'bar'), foo = _ref[0], bar = _ref[1];
          baz = {
            foo: foo,
            bar: bar
          };
          return output.sendDone({
            baz: baz
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.data.foo).to.equal('boo');
          chai.expect(ip.data.bar).to.equal('bar');
          return done();
        });
      });
      sin1.post(new noflo.IP('data', 'foo'));
      sin2.post(new noflo.IP('data', 'bar'));
      return sin1.post(new noflo.IP('data', 'boo'));
    });
    it('should keep last data-typed IP packet for controls', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string',
            control: true
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, _ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          _ref = input.getData('foo', 'bar'), foo = _ref[0], bar = _ref[1];
          baz = {
            foo: foo,
            bar: bar
          };
          return output.sendDone({
            baz: baz
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.data.foo).to.equal('boo');
          chai.expect(ip.data.bar).to.equal('bar');
          return done();
        });
      });
      sin1.post(new noflo.IP('data', 'foo'));
      sin2.post(new noflo.IP('openBracket'));
      sin2.post(new noflo.IP('data', 'bar'));
      sin2.post(new noflo.IP('closeBracket'));
      return sin1.post(new noflo.IP('data', 'boo'));
    });
    it('should isolate packets with different scopes', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string'
          }
        },
        process: function(input, output) {
          var bar, foo, _ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          _ref = input.getData('foo', 'bar'), foo = _ref[0], bar = _ref[1];
          return output.sendDone({
            baz: "" + foo + " and " + bar
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.scope).to.equal('1');
        chai.expect(ip.data).to.equal('Josh and Laura');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.scope).to.equal('2');
          chai.expect(ip.data).to.equal('Jane and Luke');
          return done();
        });
      });
      sin1.post(new noflo.IP('data', 'Josh', {
        scope: '1'
      }));
      sin2.post(new noflo.IP('data', 'Luke', {
        scope: '2'
      }));
      sin2.post(new noflo.IP('data', 'Laura', {
        scope: '1'
      }));
      return sin1.post(new noflo.IP('data', 'Jane', {
        scope: '2'
      }));
    });
    it('should be able to change scope', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string'
          }
        },
        process: function(input, output) {
          var foo;
          foo = input.getData('foo');
          return output.sendDone({
            baz: new noflo.IP('data', foo, {
              scope: 'baz'
            })
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.scope).to.equal('baz');
        chai.expect(ip.data).to.equal('foo');
        return done();
      });
      return sin1.post(new noflo.IP('data', 'foo', {
        scope: 'foo'
      }));
    });
    it('should support integer scopes', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string'
          }
        },
        process: function(input, output) {
          var bar, foo, _ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          _ref = input.getData('foo', 'bar'), foo = _ref[0], bar = _ref[1];
          return output.sendDone({
            baz: "" + foo + " and " + bar
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.scope).to.equal(1);
        chai.expect(ip.data).to.equal('Josh and Laura');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.scope).to.equal(0);
          chai.expect(ip.data).to.equal('Jane and Luke');
          return sout1.once('ip', function(ip) {
            chai.expect(ip).to.be.an('object');
            chai.expect(ip.type).to.equal('data');
            chai.expect(ip.scope).to.be["null"];
            chai.expect(ip.data).to.equal('Tom and Anna');
            return done();
          });
        });
      });
      sin1.post(new noflo.IP('data', 'Tom'));
      sin1.post(new noflo.IP('data', 'Josh', {
        scope: 1
      }));
      sin2.post(new noflo.IP('data', 'Luke', {
        scope: 0
      }));
      sin2.post(new noflo.IP('data', 'Laura', {
        scope: 1
      }));
      sin1.post(new noflo.IP('data', 'Jane', {
        scope: 0
      }));
      return sin2.post(new noflo.IP('data', 'Anna'));
    });
    it('should preserve order between input and output', function(done) {
      var ip, sample, _i, _len, _results;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'object'
          }
        },
        ordered: true,
        process: function(input, output) {
          var delay, msg, _ref;
          if (!input.has('msg', 'delay')) {
            return;
          }
          _ref = input.getData('msg', 'delay'), msg = _ref[0], delay = _ref[1];
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }
      ];
      sout1.on('ip', function(ip) {
        chai.expect(ip.data).to.eql(sample.shift());
        if (sample.length === 0) {
          return done();
        }
      });
      _results = [];
      for (_i = 0, _len = sample.length; _i < _len; _i++) {
        ip = sample[_i];
        sin1.post(new noflo.IP('data', ip.msg));
        _results.push(sin2.post(new noflo.IP('data', ip.delay)));
      }
      return _results;
    });
    it('should ignore order between input and output', function(done) {
      var count, ip, sample, _i, _len, _results;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'object'
          }
        },
        ordered: false,
        process: function(input, output) {
          var delay, msg, _ref;
          if (!input.has('msg', 'delay')) {
            return;
          }
          _ref = input.getData('msg', 'delay'), msg = _ref[0], delay = _ref[1];
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }
      ];
      count = 0;
      sout1.on('ip', function(ip) {
        var src;
        count++;
        switch (count) {
          case 1:
            src = sample[1];
            break;
          case 2:
            src = sample[3];
            break;
          case 3:
            src = sample[2];
            break;
          case 4:
            src = sample[0];
        }
        chai.expect(ip.data).to.eql(src);
        if (count === 4) {
          return done();
        }
      });
      _results = [];
      for (_i = 0, _len = sample.length; _i < _len; _i++) {
        ip = sample[_i];
        sin1.post(new noflo.IP('data', ip.msg));
        _results.push(sin2.post(new noflo.IP('data', ip.delay)));
      }
      return _results;
    });
    it('should throw errors if there is no error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(function() {
            return output.done(new Error('Should fail'));
          }).to["throw"](Error);
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      return sin1.post(new noflo.IP('data', 'some-data'));
    });
    it('should throw errors if there is a non-attached error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            datatype: 'object',
            required: true
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(function() {
            return output.sendDone(new Error('Should fail'));
          }).to["throw"](Error);
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      return sin1.post(new noflo.IP('data', 'some-data'));
    });
    it('should not throw errors if there is a non-required error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            required: false
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          output.sendDone(new Error('Should not fail'));
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      return sin1.post(new noflo.IP('data', 'some-data'));
    });
    it('should send out string other port if there is only one port aside from error', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'all',
            required: true
          }
        },
        outPorts: {
          out: {
            required: true
          },
          error: {
            required: false
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          return output.sendDone('some data');
        }
      });
      sout1.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.data).to.equal('some data');
        return done();
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      return sin1.post(new noflo.IP('data', 'first'));
    });
    it('should send object out other port if there is only one port aside from error', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'all',
            required: true
          }
        },
        outPorts: {
          out: {
            required: true
          },
          error: {
            required: false
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          return output.sendDone({
            some: 'data'
          });
        }
      });
      sout1.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.data).to.eql({
          some: 'data'
        });
        return done();
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      return sin1.post(new noflo.IP('data', 'first'));
    });
    it('should throw an error if sending without specifying a port and there are multiple ports', function(done) {
      var e;
      try {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string',
              required: true
            }
          },
          outPorts: {
            out: {
              datatype: 'all'
            },
            eh: {
              required: false
            },
            error: {
              required: false
            }
          },
          process: function(input, output) {
            return output.sendDone('test');
          }
        });
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'some-data'));
      } catch (_error) {
        e = _error;
        return done();
      }
    });
    it('should send errors if there is a connected error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(packet.scope).to.equal('some-scope');
          return output.sendDone(new Error('Should fail'));
        }
      });
      sout1.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.data).to.be.an.instanceOf(Error);
        chai.expect(ip.scope).to.equal('some-scope');
        return done();
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.error.attach(sout1);
      return sin1.post(new noflo.IP('data', 'some-data', {
        scope: 'some-scope'
      }));
    });
    it('should send substreams with multiple errors per activation', function(done) {
      var actual, count, expected;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var errors, packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(packet.scope).to.equal('some-scope');
          errors = [];
          errors.push(new Error('One thing is invalid'));
          errors.push(new Error('Another thing is invalid'));
          return output.sendDone(errors);
        }
      });
      expected = ['<', 'One thing is invalid', 'Another thing is invalid', '>'];
      actual = [];
      count = 0;
      sout1.on('ip', function(ip) {
        count++;
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.scope).to.equal('some-scope');
        if (ip.type === 'openBracket') {
          actual.push('<');
        }
        if (ip.type === 'closeBracket') {
          actual.push('>');
        }
        if (ip.type === 'data') {
          chai.expect(ip.data).to.be.an.instanceOf(Error);
          actual.push(ip.data.message);
        }
        if (count === 4) {
          chai.expect(actual).to.eql(expected);
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.error.attach(sout1);
      return sin1.post(new noflo.IP('data', 'some-data', {
        scope: 'some-scope'
      }));
    });
    it('should forward brackets for map-style components', function(done) {
      var actual, count, data, source, _i, _len, _results;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          if (typeof str !== 'string') {
            return output.sendDone(new Error('Input is not string'));
          }
          return output.pass(str.toUpperCase());
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      source = ['<', 'foo', 'bar', '>'];
      actual = [];
      count = 0;
      sout1.on('ip', function(ip) {
        var data;
        data = (function() {
          switch (ip.type) {
            case 'openBracket':
              return '<';
            case 'closeBracket':
              return '>';
            default:
              return ip.data;
          }
        })();
        chai.expect(data).to.equal(source[count].toUpperCase());
        count++;
        if (count === 4) {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        if (ip.type !== 'data') {
          return;
        }
        console.log('Unexpected error', ip);
        return done(ip.data);
      });
      _results = [];
      for (_i = 0, _len = source.length; _i < _len; _i++) {
        data = source[_i];
        switch (data) {
          case '<':
            _results.push(sin1.post(new noflo.IP('openBracket')));
            break;
          case '>':
            _results.push(sin1.post(new noflo.IP('closeBracket')));
            break;
          default:
            _results.push(sin1.post(new noflo.IP('data', data)));
        }
      }
      return _results;
    });
    it('should forward brackets to error port in async components', function(done) {
      var count;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          return setTimeout(function() {
            if (typeof str !== 'string') {
              return output.sendDone(new Error('Input is not string'));
            }
            return output.pass(str.toUpperCase());
          }, 10);
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sout1.on('ip', function(ip) {});
      count = 0;
      sout2.on('ip', function(ip) {
        count++;
        switch (count) {
          case 1:
            chai.expect(ip.type).to.equal('openBracket');
            break;
          case 2:
            chai.expect(ip.type).to.equal('data');
            chai.expect(ip.data).to.be.an('error');
            break;
          case 3:
            chai.expect(ip.type).to.equal('closeBracket');
        }
        if (count === 3) {
          return done();
        }
      });
      sin1.post(new noflo.IP('openBracket', 'foo'));
      sin1.post(new noflo.IP('data', {
        bar: 'baz'
      }));
      return sin1.post(new noflo.IP('closeBracket', 'foo'));
    });
    it('should not forward brackets if error port is not connected', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string',
            required: true
          },
          error: {
            datatype: 'object',
            required: true
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          return setTimeout(function() {
            if (typeof str !== 'string') {
              return output.sendDone(new Error('Input is not string'));
            }
            return output.pass(str.toUpperCase());
          }, 10);
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      sout1.on('ip', function(ip) {
        if (ip.type === 'closeBracket') {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        return done(new Error("Unexpected error IP: " + ip.type + " " + ip.data));
      });
      return chai.expect(function() {
        sin1.post(new noflo.IP('openBracket', 'foo'));
        sin1.post(new noflo.IP('data', 'bar'));
        return sin1.post(new noflo.IP('closeBracket', 'foo'));
      }).to.not["throw"]();
    });
    it('should support custom bracket forwarding mappings with auto-ordering', function(done) {
      var count, errCount, ip, sample, _i, _len;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        forwardBrackets: {
          msg: ['out', 'error'],
          delay: ['error']
        },
        process: function(input, output) {
          var delay, msg, _ref;
          if (!input.has('msg', 'delay')) {
            return;
          }
          _ref = input.getData('msg', 'delay'), msg = _ref[0], delay = _ref[1];
          if (delay < 0) {
            return output.sendDone(new Error('Delay is negative'));
          }
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }, {
          delay: -40,
          msg: 'five'
        }
      ];
      count = 0;
      errCount = 0;
      sout1.on('ip', function(ip) {
        var src;
        src = null;
        switch (count) {
          case 0:
            chai.expect(ip.type).to.equal('openBracket');
            chai.expect(ip.data).to.equal('msg');
            break;
          case 5:
            chai.expect(ip.type).to.equal('closeBracket');
            chai.expect(ip.data).to.equal('msg');
            break;
          default:
            src = sample[count - 1];
        }
        if (src) {
          chai.expect(ip.data).to.eql(src);
        }
        return count++;
      });
      sout2.on('ip', function(ip) {
        switch (errCount) {
          case 0:
            chai.expect(ip.type).to.equal('openBracket');
            chai.expect(ip.data).to.equal('msg');
            break;
          case 1:
            chai.expect(ip.type).to.equal('openBracket');
            chai.expect(ip.data).to.equal('delay');
            break;
          case 2:
            chai.expect(ip.type).to.equal('data');
            chai.expect(ip.data).to.be.an.error;
            break;
          case 3:
            chai.expect(ip.type).to.equal('closeBracket');
            chai.expect(ip.data).to.equal('delay');
            break;
          case 4:
            chai.expect(ip.type).to.equal('closeBracket');
            chai.expect(ip.data).to.equal('msg');
        }
        errCount++;
        if (errCount === 5) {
          return done();
        }
      });
      sin1.post(new noflo.IP('openBracket', 'msg'));
      sin2.post(new noflo.IP('openBracket', 'delay'));
      for (_i = 0, _len = sample.length; _i < _len; _i++) {
        ip = sample[_i];
        sin1.post(new noflo.IP('data', ip.msg));
        sin2.post(new noflo.IP('data', ip.delay));
      }
      sin1.post(new noflo.IP('closeBracket', 'msg'));
      return sin2.post(new noflo.IP('closeBracket', 'delay'));
    });
    it('should not apply auto-ordering if that option is false', function(done) {
      var count, ip, sample, _i, _len;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'object'
          }
        },
        ordered: false,
        autoOrdering: false,
        process: function(input, output) {
          var delay, msg, _ref;
          if (input.ip.type !== 'data') {
            return input.get(input.port.name);
          }
          if (!input.has('msg', 'delay')) {
            return;
          }
          _ref = input.getData('msg', 'delay'), msg = _ref[0], delay = _ref[1];
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }
      ];
      count = 0;
      sout1.on('ip', function(ip) {
        var src;
        count++;
        switch (count) {
          case 1:
            src = sample[1];
            break;
          case 2:
            src = sample[3];
            break;
          case 3:
            src = sample[2];
            break;
          case 4:
            src = sample[0];
        }
        chai.expect(ip.data).to.eql(src);
        if (count === 4) {
          return done();
        }
      });
      sin1.post(new noflo.IP('openBracket', 'msg'));
      sin2.post(new noflo.IP('openBracket', 'delay'));
      for (_i = 0, _len = sample.length; _i < _len; _i++) {
        ip = sample[_i];
        sin1.post(new noflo.IP('data', ip.msg));
        sin2.post(new noflo.IP('data', ip.delay));
      }
      sin1.post(new noflo.IP('closeBracket', 'msg'));
      return sin2.post(new noflo.IP('closeBracket', 'delay'));
    });
    it('should forward noflo.IP metadata for map-style components', function(done) {
      var count, n, source, str, _i, _len, _results;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          if (typeof str !== 'string') {
            return output.sendDone(new Error('Input is not string'));
          }
          return output.pass(str.toUpperCase());
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      source = ['foo', 'bar', 'baz'];
      count = 0;
      sout1.on('ip', function(ip) {
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.count).to.be.a('number');
        chai.expect(ip.length).to.be.a('number');
        chai.expect(ip.data).to.equal(source[ip.count].toUpperCase());
        chai.expect(ip.length).to.equal(source.length);
        count++;
        if (count === source.length) {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        console.log('Unexpected error', ip);
        return done(ip.data);
      });
      n = 0;
      _results = [];
      for (_i = 0, _len = source.length; _i < _len; _i++) {
        str = source[_i];
        _results.push(sin1.post(new noflo.IP('data', str, {
          count: n++,
          length: source.length
        })));
      }
      return _results;
    });
    it('should be safe dropping IPs', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var data;
          data = input.get('in');
          data.drop();
          output.done();
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sout1.on('ip', function(ip) {
        return done(ip);
      });
      return sin1.post(new noflo.IP('data', 'foo', {
        meta: 'bar'
      }));
    });
    describe('with custom callbacks', function() {
      beforeEach(function(done) {
        c = new noflo.Component({
          inPorts: {
            foo: {
              datatype: 'string'
            },
            bar: {
              datatype: 'int',
              control: true
            }
          },
          outPorts: {
            baz: {
              datatype: 'object'
            },
            err: {
              datatype: 'object'
            }
          },
          ordered: true,
          activateOnInput: false,
          process: function(input, output, done) {
            var bar, baz, foo, _ref;
            if (!input.has('foo', 'bar')) {
              return;
            }
            _ref = input.getData('foo', 'bar'), foo = _ref[0], bar = _ref[1];
            if (bar < 0 || bar > 1000) {
              return output.sendDone({
                err: new Error("Bar is not correct: " + bar)
              });
            }
            input.activate();
            output.send({
              baz: new noflo.IP('openBracket')
            });
            baz = {
              foo: foo,
              bar: bar
            };
            output.send({
              baz: baz
            });
            return setTimeout(function() {
              output.send({
                baz: new noflo.IP('closeBracket')
              });
              return done();
            }, bar);
          }
        });
        c.inPorts.foo.attach(sin1);
        c.inPorts.bar.attach(sin2);
        c.outPorts.baz.attach(sout1);
        c.outPorts.err.attach(sout2);
        return done();
      });
      it('should fail on wrong input', function(done) {
        sout1.once('ip', function(ip) {
          return done(new Error('Unexpected baz'));
        });
        sout2.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.data).to.be.an.error;
          chai.expect(ip.data.message).to.contain('Bar');
          return done();
        });
        sin1.post(new noflo.IP('data', 'fff'));
        return sin2.post(new noflo.IP('data', -120));
      });
      return it('should send substreams', function(done) {
        var actual, count, expected, item, sample, _i, _len, _results;
        sample = [
          {
            bar: 30,
            foo: "one"
          }, {
            bar: 0,
            foo: "two"
          }
        ];
        expected = ['<', 'one', '>', '<', 'two', '>'];
        actual = [];
        count = 0;
        sout1.on('ip', function(ip) {
          count++;
          switch (ip.type) {
            case 'openBracket':
              actual.push('<');
              break;
            case 'closeBracket':
              actual.push('>');
              break;
            default:
              actual.push(ip.data.foo);
          }
          if (count === 6) {
            chai.expect(actual).to.eql(expected);
            return done();
          }
        });
        sout2.once('ip', function(ip) {
          return done(ip.data);
        });
        _results = [];
        for (_i = 0, _len = sample.length; _i < _len; _i++) {
          item = sample[_i];
          sin2.post(new noflo.IP('data', item.bar));
          _results.push(sin1.post(new noflo.IP('data', item.foo)));
        }
        return _results;
      });
    });
    return describe('using buffers', function() {
      it('should get from buffer using a name', function(done) {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var buf;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            buf = input.buffer.get('in', function(ip) {
              return ip.type === 'data';
            });
            chai.expect(buf[0].data).to.eql('foo');
            chai.expect(buf).to.eql(input.ports["in"].buffer);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'foo'));
      });
      it('should filter everything from the buffer using no name', function(done) {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            },
            error: {
              datatype: 'object'
            }
          },
          process: function(input, output) {
            var buffer, originalBuffer;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            originalBuffer = input.buffer.get();
            input.buffer.filter(function(ip) {
              return false;
            });
            buffer = input.buffer.get();
            chai.expect(originalBuffer.length).to.eql(1);
            chai.expect(buffer).to.eql([]);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'foo'));
      });
      it('should filter everything from the scoped buffer using no name', function(done) {
        var ip;
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            },
            error: {
              datatype: 'object'
            }
          },
          process: function(input, output) {
            var buffer, originalBuffer;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            originalBuffer = input.buffer.get();
            input.buffer.filter(function(ip) {
              return false;
            });
            buffer = input.buffer.get();
            chai.expect(originalBuffer.length).to.eql(1);
            chai.expect(buffer).to.eql([]);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        ip = new noflo.IP('data', 'foo');
        ip.scope = 'eh';
        return sin1.post(ip);
      });
      it('should find from the buffer using a name', function(done) {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            },
            error: {
              datatype: 'object'
            }
          },
          process: function(input, output) {
            var bufferedData;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            bufferedData = input.buffer.find('in', function(ip) {
              if (ip.data != null) {
                return true;
              } else {
                return false;
              }
            });
            chai.expect(bufferedData[0].data).to.eql('foo');
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'foo'));
      });
      it('should get scoped buffer using a name ', function(done) {
        var ip;
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var buf;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            buf = input.buffer.get('in');
            chai.expect(buf).to.eql(input.ports["in"].scopedBuffer.eh);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        ip = new noflo.IP('data', 'foo');
        ip.scope = 'eh';
        return sin1.post(ip);
      });
      it('should set a buffer using a name', function(done) {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var bufferedData;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            input.buffer.set('in', []);
            bufferedData = input.buffer.get('in');
            chai.expect(bufferedData).to.eql([]);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'foo'));
      });
      it('should set a buffer without a name', function(done) {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var bufferedData;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            input.buffer.set([]);
            bufferedData = input.buffer.get();
            chai.expect(bufferedData).to.eql([]);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'foo'));
      });
      it('should set a scoped buffer using a name', function(done) {
        var ip;
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var bufferedData;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            input.buffer.set('in', []);
            bufferedData = input.buffer.get('in');
            chai.expect(bufferedData).to.eql([]);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        ip = new noflo.IP('data', 'foo');
        ip.scope = 'eh';
        return sin1.post(ip);
      });
      return it('should set a scoped buffer without a name', function(done) {
        var ip;
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var bufferedData;
            if (!input.has('in', function(ip) {
              return ip.type === 'data';
            })) {
              return;
            }
            input.buffer.set([]);
            bufferedData = input.buffer.get();
            chai.expect(bufferedData).to.eql([]);
            return done();
          }
        });
        c.inPorts["in"].attach(sin1);
        ip = new noflo.IP('data', 'foo');
        ip.scope = 'eh';
        return sin1.post(ip);
      });
    });
  });
});
