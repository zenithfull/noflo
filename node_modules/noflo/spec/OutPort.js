var chai, noflo;

if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
  if (!chai) {
    chai = require('chai');
  }
  noflo = require('../src/lib/NoFlo.coffee');
} else {
  noflo = require('noflo');
}

describe('Outport Port', function() {
  describe('with addressable ports', function() {
    var s1, s2, s3;
    s1 = s2 = s3 = null;
    beforeEach(function() {
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      return s3 = new noflo.internalSocket.InternalSocket;
    });
    it('should be able to send to a specific port', function() {
      var p;
      p = new noflo.OutPort({
        addressable: true
      });
      p.attach(s1);
      p.attach(s2);
      p.attach(s3);
      chai.expect(p.listAttached()).to.eql([0, 1, 2]);
      s1.on('data', function() {
        return chai.expect(true).to.equal(false);
      });
      s2.on('data', function(data) {
        return chai.expect(data).to.equal('some-data');
      });
      s3.on('data', function() {
        return chai.expect(true).to.equal(false);
      });
      return p.send('some-data', 1);
    });
    it('should be able to send to index 0', function(done) {
      var p;
      p = new noflo.OutPort({
        addressable: true
      });
      p.attach(s1);
      s1.on('data', function(data) {
        chai.expect(data).to.equal('my-data');
        return done();
      });
      return p.send('my-data', 0);
    });
    it('should throw an error when sent data without address', function() {
      return chai.expect(function() {
        return p.send('some-data');
      }).to["throw"];
    });
    it('should throw an error when a specific port is requested with non-addressable port', function() {
      var p;
      p = new noflo.OutPort;
      p.attach(s1);
      p.attach(s2);
      p.attach(s3);
      return chai.expect(function() {
        return p.send('some-data', 1);
      }).to["throw"];
    });
    return it('should give correct port index when detaching a connection', function(done) {
      var expected, expectedAttached, expectedSockets, p;
      p = new noflo.OutPort({
        addressable: true
      });
      p.attach(s1, 3);
      p.attach(s2, 1);
      p.attach(s3, 5);
      expectedSockets = [s2, s3];
      expected = [1, 5];
      expectedAttached = [[3, 5], [3]];
      p.on('detach', function(socket, index) {
        var att, atts, _i, _len;
        chai.expect(socket).to.equal(expectedSockets.shift());
        chai.expect(index).to.equal(expected.shift());
        chai.expect(p.isAttached(index)).to.equal(false);
        atts = expectedAttached.shift();
        chai.expect(p.listAttached()).to.eql(atts);
        for (_i = 0, _len = atts.length; _i < _len; _i++) {
          att = atts[_i];
          chai.expect(p.isAttached(att)).to.equal(true);
        }
        if (!expected.length) {
          return done();
        }
      });
      p.detach(s2);
      return p.detach(s3);
    });
  });
  describe('with caching ports', function() {
    var s1, s2, s3;
    s1 = s2 = s3 = null;
    beforeEach(function() {
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      return s3 = new noflo.internalSocket.InternalSocket;
    });
    it('should repeat the previously sent value on attach event', function(done) {
      var p;
      p = new noflo.OutPort({
        caching: true
      });
      s1.once('data', function(data) {
        return chai.expect(data).to.equal('foo');
      });
      s2.once('data', function(data) {
        chai.expect(data).to.equal('foo');
        return s2.once('data', function(data) {
          chai.expect(data).to.equal('bar');
          return done();
        });
      });
      p.attach(s1);
      p.send('foo');
      p.disconnect();
      p.attach(s2);
      p.send('bar');
      return p.disconnect();
    });
    return it('should support addressable ports', function(done) {
      var p;
      p = new noflo.OutPort({
        addressable: true,
        caching: true
      });
      p.attach(s1);
      p.attach(s2);
      s1.on('data', function() {
        return chai.expect(true).to.equal(false);
      });
      s2.on('data', function(data) {
        return chai.expect(data).to.equal('some-data');
      });
      s3.on('data', function(data) {
        chai.expect(data).to.equal('some-data');
        return done();
      });
      p.send('some-data', 1);
      p.disconnect(1);
      p.detach(s2);
      return p.attach(s3, 1);
    });
  });
  return describe('with IP objects', function() {
    var s1, s2, s3;
    s1 = s2 = s3 = null;
    beforeEach(function() {
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      return s3 = new noflo.internalSocket.InternalSocket;
    });
    it('should send data IPs and substreams', function(done) {
      var count, expectedEvents, p;
      p = new noflo.OutPort;
      p.attach(s1);
      expectedEvents = ['data', 'openBracket', 'data', 'closeBracket'];
      count = 0;
      s1.on('ip', function(data) {
        count++;
        chai.expect(data).to.be.an('object');
        chai.expect(data.type).to.equal(expectedEvents.shift());
        if (data.type === 'data') {
          chai.expect(data.data).to.equal('my-data');
        }
        if (count === 4) {
          return done();
        }
      });
      p.data('my-data');
      return p.openBracket().data('my-data').closeBracket();
    });
    it('should send non-clonable objects by reference', function(done) {
      var obj, p;
      p = new noflo.OutPort;
      p.attach(s1);
      p.attach(s2);
      p.attach(s3);
      obj = {
        foo: 123,
        bar: {
          boo: 'baz'
        },
        func: function() {
          return this.foo = 456;
        }
      };
      s1.on('ip', function(data) {
        chai.expect(data).to.be.an('object');
        chai.expect(data.data).to.equal(obj);
        chai.expect(data.data.func).to.be.a('function');
        return s2.on('ip', function(data) {
          chai.expect(data).to.be.an('object');
          chai.expect(data.data).to.equal(obj);
          chai.expect(data.data.func).to.be.a('function');
          return s3.on('ip', function(data) {
            chai.expect(data).to.be.an('object');
            chai.expect(data.data).to.equal(obj);
            chai.expect(data.data.func).to.be.a('function');
            return done();
          });
        });
      });
      return p.data(obj, {
        clonable: false
      });
    });
    return it('should clone clonable objects on fan-out', function(done) {
      var obj, p;
      p = new noflo.OutPort;
      p.attach(s1);
      p.attach(s2);
      p.attach(s3);
      obj = {
        foo: 123,
        bar: {
          boo: 'baz'
        },
        func: function() {
          return this.foo = 456;
        }
      };
      s1.on('ip', function(data) {
        chai.expect(data).to.be.an('object');
        chai.expect(data.data).to.equal(obj);
        chai.expect(data.data.func).to.be.a('function');
        return s2.on('ip', function(data) {
          chai.expect(data).to.be.an('object');
          chai.expect(data.data).to.not.equal(obj);
          chai.expect(data.data.foo).to.equal(obj.foo);
          chai.expect(data.data.bar).to.eql(obj.bar);
          chai.expect(data.data.func).to.be.undefined;
          return s3.on('ip', function(data) {
            chai.expect(data).to.be.an('object');
            chai.expect(data.data).to.not.equal(obj);
            chai.expect(data.data.foo).to.equal(obj.foo);
            chai.expect(data.data.bar).to.eql(obj.bar);
            chai.expect(data.data.func).to.be.undefined;
            return done();
          });
        });
      });
      return p.data(obj, {
        clonable: true
      });
    });
  });
});
