(function() {
  var TraceBuffer, Tracer, clone, debug, e, error, jsonStringify, networkToTraceEvent, noflo, subscribeExportedOutports;

  noflo = require('noflo');

  debug = require('debug')('noflo-runtime-base:trace');

  jsonStringify = JSON.stringify;

  try {
    jsonStringify = require('json-stringify-safe');
  } catch (error) {
    e = error;
    console.log("WARN: failed to load json-stringify-safe, circular objects may cause fail.\n" + e.message);
  }

  clone = function(obj) {
    var s;
    s = jsonStringify(obj);
    return JSON.parse(s);
  };

  TraceBuffer = (function() {
    function TraceBuffer() {
      this.events = [];
    }

    TraceBuffer.prototype.add = function(event) {
      return this.events.push(event);
    };

    TraceBuffer.prototype.getAll = function(consumeFunc, doneFunc) {
      var i, len, ref;
      ref = this.events;
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        consumeFunc(e);
      }
      return doneFunc(null);
    };

    return TraceBuffer;

  })();

  subscribeExportedOutports = function(network, networkId, eventNames, subscribeFunc) {
    var component, event, graphSockets, i, internal, len, pub, ref, sendFunc, socket;
    graphSockets = {};
    ref = network.graph.outports;
    for (pub in ref) {
      internal = ref[pub];
      socket = noflo.internalSocket.createSocket();
      graphSockets[pub] = socket;
      component = network.processes[internal.process].component;
      component.outPorts[internal.port].attach(socket);
      sendFunc = function(event) {
        return function(payload) {
          var data;
          data = {
            id: "EXPORT: " + networkId + " " + (pub.toUpperCase()) + " ->",
            payload: payload,
            socket: {
              to: {
                process: {
                  id: networkId
                },
                port: pub
              }
            }
          };
          return subscribeFunc(event, data);
        };
      };
      for (i = 0, len = eventNames.length; i < len; i++) {
        event = eventNames[i];
        socket.on(event, sendFunc(event));
      }
    }
    return graphSockets;
  };

  networkToTraceEvent = function(networkId, type, data) {
    var error1, event, p, ref, ref1, ref2, ref3, serializeGroup, socket;
    debug('event', networkId, type, "'" + data.id + "'");
    socket = data.socket;
    event = {
      protocol: 'network',
      command: type,
      payload: {
        time: new Date().toISOString(),
        graph: networkId,
        error: null,
        src: {
          node: (ref = socket.from) != null ? ref.process.id : void 0,
          port: (ref1 = socket.from) != null ? ref1.port : void 0
        },
        tgt: {
          node: (ref2 = socket.to) != null ? ref2.process.id : void 0,
          port: (ref3 = socket.to) != null ? ref3.port : void 0
        },
        id: void 0,
        subgraph: void 0
      }
    };
    serializeGroup = function(p) {
      var error1;
      try {
        return p.group = data.group.toString();
      } catch (error1) {
        e = error1;
        debug('group serialization error', e);
        return p.error = e.message;
      }
    };
    p = event.payload;
    switch (type) {
      case 'connect':
        null;
        break;
      case 'disconnect':
        null;
        break;
      case 'begingroup':
        serializeGroup(event.payload);
        break;
      case 'endgroup':
        serializeGroup(event.payload);
        break;
      case 'data':
        try {
          p.data = clone(data.data);
        } catch (error1) {
          e = error1;
          debug('data serialization error', e);
          p.error = e.message;
        }
        break;
      default:
        throw new Error("trace: Unknown event type " + type);
    }
    debug('event done', networkId, type, "'" + data.id + "'");
    return event;
  };

  Tracer = (function() {
    function Tracer(options) {
      this.options = options;
      this.buffer = new TraceBuffer;
      this.header = {
        graphs: {}
      };
    }

    Tracer.prototype.attach = function(network) {
      var eventNames, netId, sockets;
      netId = network.graph.name || network.graph.properties.name || 'default';
      debug('attach', netId);
      eventNames = ['connect', 'begingroup', 'data', 'endgroup', 'disconnect'];
      eventNames.forEach((function(_this) {
        return function(event) {
          return network.on(event, function(data) {
            var payload;
            payload = networkToTraceEvent(netId, event, data);
            return _this.buffer.add(payload);
          });
        };
      })(this));
      sockets = subscribeExportedOutports(network, netId, eventNames, (function(_this) {
        return function(event, data) {
          var payload;
          payload = networkToTraceEvent(netId, event, data);
          return _this.buffer.add(payload);
        };
      })(this));
      return this.header.graphs[netId] = network.graph.toJSON();
    };

    Tracer.prototype.detach = function(network) {};

    Tracer.prototype.dumpString = function(callback) {
      var consume, events;
      events = [];
      consume = function(e) {
        return events.push(e);
      };
      return this.buffer.getAll(consume, (function(_this) {
        return function(err) {
          var trace;
          trace = {
            header: _this.header,
            events: events
          };
          return callback(err, JSON.stringify(trace, null, 2));
        };
      })(this));
    };

    Tracer.prototype.dumpFile = function(filepath, callback) {
      var fs, openFile, temp;
      fs = require('fs');
      temp = require('temp');
      openFile = function(cb) {
        return fs.open(filepath, 'w', function(err, fd) {
          return cb(err, {
            path: filepath,
            fd: fd
          });
        });
      };
      if (!filepath) {
        openFile = function(cb) {
          return temp.open({
            suffix: '.json'
          }, cb);
        };
      }
      return openFile((function(_this) {
        return function(err, info) {
          var events, header, write, writeEvent;
          if (err) {
            return callback(err);
          }
          events = 0;
          write = function(data, cb) {
            return fs.write(info.fd, data, {
              encoding: 'utf-8'
            }, cb);
          };
          writeEvent = function(e) {
            var s;
            s = events ? ',' : '';
            events += 1;
            s += JSON.stringify(e, null, 2);
            return write(s, function(err) {});
          };
          debug('streaming to file', info.path);
          header = JSON.stringify(_this.header, null, 2);
          return write("{\n \"header\": " + header + "\n, \"events\":\n[", function(err) {
            return _this.buffer.getAll(writeEvent, function(err) {
              if (err) {
                return callback(err);
              }
              debug("streamed " + events + " events");
              return write(']\n }', function(err) {
                debug("completed stream", info.path);
                return callback(err, info.path);
              });
            });
          });
        };
      })(this));
    };

    return Tracer;

  })();

  module.exports.Tracer = Tracer;

}).call(this);
