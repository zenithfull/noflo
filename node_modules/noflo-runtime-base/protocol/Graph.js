(function() {
  var GraphProtocol, noflo;

  noflo = require('noflo');

  GraphProtocol = (function() {
    function GraphProtocol(transport) {
      this.transport = transport;
      this.graphs = {};
    }

    GraphProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('graph', topic, payload, context);
    };

    GraphProtocol.prototype.sendAll = function(topic, payload) {
      return this.transport.sendAll('graph', topic, payload);
    };

    GraphProtocol.prototype.receive = function(topic, payload, context) {
      var graph;
      if (!this.transport.canDo('protocol:graph', payload.secret)) {
        this.send('error', new Error(topic + " not permitted"), context);
        return;
      }
      if (topic !== 'clear') {
        graph = this.resolveGraph(payload, context);
        if (!graph) {
          return;
        }
      }
      switch (topic) {
        case 'clear':
          return this.initGraph(payload, context);
        case 'addnode':
          return this.addNode(graph, payload, context);
        case 'removenode':
          return this.removeNode(graph, payload, context);
        case 'renamenode':
          return this.renameNode(graph, payload, context);
        case 'changenode':
          return this.changeNode(graph, payload, context);
        case 'addedge':
          return this.addEdge(graph, payload, context);
        case 'removeedge':
          return this.removeEdge(graph, payload, context);
        case 'changeedge':
          return this.changeEdge(graph, payload, context);
        case 'addinitial':
          return this.addInitial(graph, payload, context);
        case 'removeinitial':
          return this.removeInitial(graph, payload, context);
        case 'addinport':
          return this.addInport(graph, payload, context);
        case 'removeinport':
          return this.removeInport(graph, payload, context);
        case 'renameinport':
          return this.renameInport(graph, payload, context);
        case 'addoutport':
          return this.addOutport(graph, payload, context);
        case 'removeoutport':
          return this.removeOutport(graph, payload, context);
        case 'renameoutport':
          return this.renameOutport(graph, payload, context);
        case 'addgroup':
          return this.addGroup(graph, payload, context);
        case 'removegroup':
          return this.removeGroup(graph, payload, context);
        case 'renamegroup':
          return this.renameGroup(graph, payload, context);
        case 'changegroup':
          return this.changeGroup(graph, payload, context);
      }
    };

    GraphProtocol.prototype.resolveGraph = function(payload, context) {
      if (!payload.graph) {
        this.send('error', new Error('No graph specified'), context);
        return;
      }
      if (!this.graphs[payload.graph]) {
        this.send('error', new Error('Requested graph not found'), context);
        return;
      }
      return this.graphs[payload.graph];
    };

    GraphProtocol.prototype.getLoader = function(baseDir) {
      return this.transport.component.getLoader(baseDir, this.transport.options);
    };

    GraphProtocol.prototype.sendGraph = function(id, graph, context) {
      var payload;
      payload = {
        graph: id,
        description: graph.toJSON()
      };
      return this.send('graph', payload, context);
    };

    GraphProtocol.prototype.initGraph = function(payload, context) {
      var fullName, graph;
      if (!payload.id) {
        this.send('error', new Error('No graph ID provided'), context);
        return;
      }
      if (!payload.name) {
        payload.name = 'NoFlo runtime';
      }
      graph = new noflo.Graph(payload.name);
      fullName = payload.id;
      if (payload.library) {
        payload.library = payload.library.replace('noflo-', '');
        graph.properties.library = payload.library;
        fullName = payload.library + "/" + fullName;
      }
      if (payload.icon) {
        graph.properties.icon = payload.icon;
      }
      if (payload.description) {
        graph.properties.description = payload.description;
      }
      graph.baseDir = this.transport.options.baseDir;
      this.subscribeGraph(payload.id, graph, context);
      if (payload.main) {
        this.transport.runtime.setMainGraph(fullName, graph, context);
      } else {
        this.transport.component.registerGraph(fullName, graph, context);
      }
      this.graphs[payload.id] = graph;
      return this.sendAll('clear', payload, context);
    };

    GraphProtocol.prototype.registerGraph = function(id, graph) {
      if (id === 'default/main') {
        this.transport.runtime.setMainGraph(id, graph);
      }
      this.subscribeGraph(id, graph, '');
      return this.graphs[id] = graph;
    };

    GraphProtocol.prototype.subscribeGraph = function(id, graph, context) {
      graph.on('addNode', (function(_this) {
        return function(node) {
          node.graph = id;
          return _this.sendAll('addnode', node, context);
        };
      })(this));
      graph.on('removeNode', (function(_this) {
        return function(node) {
          var nodeData;
          nodeData = {
            id: node.id,
            graph: id
          };
          return _this.sendAll('removenode', nodeData, context);
        };
      })(this));
      graph.on('renameNode', (function(_this) {
        return function(oldId, newId) {
          return _this.sendAll('renamenode', {
            from: oldId,
            to: newId,
            graph: id
          }, context);
        };
      })(this));
      graph.on('changeNode', (function(_this) {
        return function(node, before) {
          return _this.sendAll('changenode', {
            id: node.id,
            metadata: node.metadata,
            graph: id
          }, context);
        };
      })(this));
      graph.on('addEdge', (function(_this) {
        return function(edge) {
          var edgeData;
          if (typeof edge.from.index !== 'number') {
            delete edge.from.index;
          }
          if (typeof edge.to.index !== 'number') {
            delete edge.to.index;
          }
          edgeData = {
            src: edge.from,
            tgt: edge.to,
            metadata: edge.metadata,
            graph: id
          };
          return _this.sendAll('addedge', edgeData, context);
        };
      })(this));
      graph.on('removeEdge', (function(_this) {
        return function(edge) {
          var edgeData;
          edgeData = {
            src: edge.from,
            tgt: edge.to,
            graph: id
          };
          return _this.sendAll('removeedge', edgeData, context);
        };
      })(this));
      graph.on('changeEdge', (function(_this) {
        return function(edge) {
          var edgeData;
          edgeData = {
            src: edge.from,
            tgt: edge.to,
            metadata: edge.metadata,
            graph: id
          };
          return _this.sendAll('changeedge', edgeData, context);
        };
      })(this));
      graph.on('addInitial', (function(_this) {
        return function(iip) {
          var iipData;
          iipData = {
            src: iip.from,
            tgt: iip.to,
            metadata: iip.metadata,
            graph: id
          };
          return _this.sendAll('addinitial', iipData, context);
        };
      })(this));
      graph.on('removeInitial', (function(_this) {
        return function(iip) {
          var iipData;
          iipData = {
            src: iip.from,
            tgt: iip.to,
            graph: id
          };
          return _this.sendAll('removeinitial', iipData, context);
        };
      })(this));
      graph.on('addGroup', (function(_this) {
        return function(group) {
          var groupData;
          groupData = {
            name: group.name,
            nodes: group.nodes,
            metadata: group.metadata,
            graph: id
          };
          return _this.sendAll('addgroup', groupData, context);
        };
      })(this));
      graph.on('removeGroup', (function(_this) {
        return function(group) {
          var groupData;
          groupData = {
            name: group.name,
            graph: id
          };
          return _this.sendAll('removegroup', groupData, context);
        };
      })(this));
      graph.on('renameGroup', (function(_this) {
        return function(oldName, newName) {
          var groupData;
          groupData = {
            from: oldName,
            to: newName,
            graph: id
          };
          return _this.sendAll('renamegroup', groupData, context);
        };
      })(this));
      graph.on('changeGroup', (function(_this) {
        return function(group) {
          var groupData;
          groupData = {
            name: group.name,
            metadata: group.metadata,
            graph: id
          };
          return _this.sendAll('changegroup', groupData, context);
        };
      })(this));
      graph.on('addInport', (function(_this) {
        return function(publicName, port) {
          var data;
          data = {
            "public": publicName,
            node: port.process,
            port: port.port,
            metadata: port.metadata,
            graph: id
          };
          return _this.sendAll('addinport', data, context);
        };
      })(this));
      graph.on('addOutport', (function(_this) {
        return function(publicName, port) {
          var data;
          data = {
            "public": publicName,
            node: port.process,
            port: port.port,
            metadata: port.metadata,
            graph: id
          };
          return _this.sendAll('addoutport', data, context);
        };
      })(this));
      graph.on('removeInport', (function(_this) {
        return function(publicName, port) {
          var data;
          data = {
            "public": publicName,
            graph: id
          };
          return _this.sendAll('removeinport', data, context);
        };
      })(this));
      return graph.on('removeOutport', (function(_this) {
        return function(publicName, port) {
          var data;
          data = {
            "public": publicName,
            graph: id
          };
          return _this.sendAll('removeoutport', data, context);
        };
      })(this));
    };

    GraphProtocol.prototype.addNode = function(graph, node, context) {
      if (!(node.id || node.component)) {
        this.send('error', new Error('No ID or component supplied'), context);
        return;
      }
      return graph.addNode(node.id, node.component, node.metadata);
    };

    GraphProtocol.prototype.removeNode = function(graph, payload, context) {
      if (!payload.id) {
        this.send('error', new Error('No ID supplied'), context);
        return;
      }
      return graph.removeNode(payload.id);
    };

    GraphProtocol.prototype.renameNode = function(graph, payload, context) {
      if (!(payload.from || payload.to)) {
        this.send('error', new Error('No from or to supplied'), context);
        return;
      }
      return graph.renameNode(payload.from, payload.to);
    };

    GraphProtocol.prototype.changeNode = function(graph, payload, context) {
      if (!(payload.id || payload.metadata)) {
        this.send('error', new Error('No id or metadata supplied'), context);
        return;
      }
      return graph.setNodeMetadata(payload.id, payload.metadata);
    };

    GraphProtocol.prototype.addEdge = function(graph, edge, context) {
      if (!(edge.src || edge.tgt)) {
        this.send('error', new Error('No src or tgt supplied'), context);
        return;
      }
      if (typeof edge.src.index === 'number' || typeof edge.tgt.index === 'number') {
        if (graph.addEdgeIndex) {
          graph.addEdgeIndex(edge.src.node, edge.src.port, edge.src.index, edge.tgt.node, edge.tgt.port, edge.tgt.index, edge.metadata);
          return;
        }
      }
      return graph.addEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port, edge.metadata);
    };

    GraphProtocol.prototype.removeEdge = function(graph, edge, context) {
      if (!(edge.src || edge.tgt)) {
        this.send('error', new Error('No src or tgt supplied'), context);
        return;
      }
      return graph.removeEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port);
    };

    GraphProtocol.prototype.changeEdge = function(graph, edge, context) {
      if (!(edge.src || edge.tgt)) {
        this.send('error', new Error('No src or tgt supplied'), context);
        return;
      }
      return graph.setEdgeMetadata(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port, edge.metadata);
    };

    GraphProtocol.prototype.addInitial = function(graph, payload, context) {
      if (!(payload.src || payload.tgt)) {
        this.send('error', new Error('No src or tgt supplied'), context);
        return;
      }
      if (graph.addInitialIndex && typeof payload.tgt.index === 'number') {
        graph.addInitialIndex(payload.src.data, payload.tgt.node, payload.tgt.port, payload.tgt.index, payload.metadata);
        return;
      }
      return graph.addInitial(payload.src.data, payload.tgt.node, payload.tgt.port, payload.metadata);
    };

    GraphProtocol.prototype.removeInitial = function(graph, payload, context) {
      if (!payload.tgt) {
        this.send('error', new Error('No tgt supplied'), context);
        return;
      }
      return graph.removeInitial(payload.tgt.node, payload.tgt.port);
    };

    GraphProtocol.prototype.addInport = function(graph, payload, context) {
      if (!(payload["public"] || payload.node || payload.port)) {
        this.send('error', new Error('Missing exported inport information'), context);
        return;
      }
      return graph.addInport(payload["public"], payload.node, payload.port, payload.metadata);
    };

    GraphProtocol.prototype.removeInport = function(graph, payload, context) {
      if (!payload["public"]) {
        this.send('error', new Error('Missing exported inport name'), context);
        return;
      }
      return graph.removeInport(payload["public"]);
    };

    GraphProtocol.prototype.renameInport = function(graph, payload, context) {
      if (!(payload.from || payload.to)) {
        this.send('error', new Error('No from or to supplied'), context);
        return;
      }
      return graph.renameInport(payload.from, payload.to);
    };

    GraphProtocol.prototype.addOutport = function(graph, payload, context) {
      if (!(payload["public"] || payload.node || payload.port)) {
        this.send('error', new Error('Missing exported outport information'), context);
        return;
      }
      return graph.addOutport(payload["public"], payload.node, payload.port, payload.metadata);
    };

    GraphProtocol.prototype.removeOutport = function(graph, payload, context) {
      if (!payload["public"]) {
        this.send('error', new Error('Missing exported outport name'), context);
        return;
      }
      return graph.removeOutport(payload["public"]);
    };

    GraphProtocol.prototype.renameOutport = function(graph, payload, context) {
      if (!(payload.from || payload.to)) {
        this.send('error', new Error('No from or to supplied'), context);
        return;
      }
      return graph.renameOutport(payload.from, payload.to);
    };

    GraphProtocol.prototype.addGroup = function(graph, payload, context) {
      if (!(payload.name || payload.nodes || payload.metadata)) {
        this.send('error', new Error('No name or nodes or metadata supplied'), context);
        return;
      }
      return graph.addGroup(payload.name, payload.nodes, payload.metadata);
    };

    GraphProtocol.prototype.removeGroup = function(graph, payload, context) {
      if (!payload.name) {
        this.send('error', new Error('No name supplied'), context);
        return;
      }
      return graph.removeGroup(payload.name);
    };

    GraphProtocol.prototype.renameGroup = function(graph, payload, context) {
      if (!(payload.from || payload.to)) {
        this.send('error', new Error('No from or to supplied'), context);
        return;
      }
      return graph.renameGroup(payload.from, payload.to);
    };

    GraphProtocol.prototype.changeGroup = function(graph, payload, context) {
      if (!(payload.name || payload.metadata)) {
        this.send('error', new Error('No name or metadata supplied'), context);
        return;
      }
      return graph.setEdgeMetadata(payload.name, payload.metadata);
    };

    return GraphProtocol;

  })();

  module.exports = GraphProtocol;

}).call(this);
