(function() {
  var RuntimeProtocol, noflo, portsPayload, sendToInport;

  noflo = require('noflo');

  sendToInport = function(component, portName, event, payload) {
    var port, socket;
    socket = noflo.internalSocket.createSocket();
    port = component.inPorts[portName];
    port.attach(socket);
    switch (event) {
      case 'connect':
        socket.connect();
        break;
      case 'disconnect':
        socket.disconnect();
        break;
      case 'begingroup':
        socket.beginGroup(payload);
        break;
      case 'endgroup':
        socket.endGroup(payload);
        break;
      case 'data':
        socket.post(payload);
    }
    return port.detach(socket);
  };

  portsPayload = function(name, graph) {
    var inports, internal, outports, payload, pub, ref, ref1, ref2, ref3;
    inports = [];
    outports = [];
    if (graph) {
      ref = graph.inports;
      for (pub in ref) {
        internal = ref[pub];
        inports.push({
          id: pub,
          type: 'any',
          description: (ref1 = internal.metadata) != null ? ref1.description : void 0,
          addressable: false,
          required: false
        });
      }
      ref2 = graph.outports;
      for (pub in ref2) {
        internal = ref2[pub];
        outports.push({
          id: pub,
          type: 'any',
          description: (ref3 = internal.metadata) != null ? ref3.description : void 0,
          addressable: false,
          required: false
        });
      }
    }
    return payload = {
      graph: name,
      inPorts: inports,
      outPorts: outports
    };
  };

  RuntimeProtocol = (function() {
    function RuntimeProtocol(transport) {
      this.transport = transport;
      this.outputSockets = {};
      this.mainGraph = null;
      this.transport.network.on('addnetwork', (function(_this) {
        return function(network, name) {
          _this.subscribeExportedPorts(name, network.graph, true);
          _this.subscribeOutPorts(name, network);
          _this.sendPorts(name, network.graph);
          if (network.isStarted()) {
            _this.subscribeOutdata(name, network, true);
          }
          return network.on('start', function() {
            return _this.subscribeOutdata(name, network, true);
          });
        };
      })(this));
      this.transport.network.on('removenetwork', (function(_this) {
        return function(network, name) {
          _this.subscribeOutdata(name, network, false);
          _this.subscribeOutPorts(name, network);
          _this.subscribeExportedPorts(name, network.graph, false);
          return _this.sendPorts(name, null);
        };
      })(this));
    }

    RuntimeProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('runtime', topic, payload, context);
    };

    RuntimeProtocol.prototype.sendAll = function(topic, payload) {
      return this.transport.sendAll('runtime', topic, payload);
    };

    RuntimeProtocol.prototype.sendError = function(message, context) {
      return this.send('error', new Error(message), context);
    };

    RuntimeProtocol.prototype.receive = function(topic, payload, context) {
      if (topic === 'packet' && !this.transport.canDo('protocol:runtime', payload.secret)) {
        this.send('error', new Error(topic + " not permitted"), context);
        return;
      }
      switch (topic) {
        case 'getruntime':
          return this.getRuntime(payload, context);
        case 'packet':
          return this.receivePacket(payload, context);
      }
    };

    RuntimeProtocol.prototype.getRuntime = function(payload, context) {
      var capabilities, name, network, permittedCapabilities, ref, results, type;
      type = this.transport.options.type;
      if (!type) {
        if (noflo.isBrowser()) {
          type = 'noflo-browser';
        } else {
          type = 'noflo-nodejs';
        }
      }
      capabilities = this.transport.options.capabilities;
      if (!capabilities) {
        capabilities = ['protocol:graph', 'protocol:component', 'protocol:network', 'protocol:runtime', 'component:setsource', 'component:getsource'];
      }
      permittedCapabilities = capabilities.filter((function(_this) {
        return function(capability) {
          return _this.transport.canDo(capability, payload.secret);
        };
      })(this));
      payload = {
        type: type,
        version: this.transport.version,
        capabilities: permittedCapabilities,
        allCapabilities: capabilities
      };
      if (this.mainGraph) {
        payload.graph = this.mainGraph;
      }
      this.send('runtime', payload, context);
      ref = this.transport.network.networks;
      results = [];
      for (name in ref) {
        network = ref[name];
        results.push(this.sendPorts(name, network.graph, context));
      }
      return results;
    };

    RuntimeProtocol.prototype.sendPorts = function(name, graph, context) {
      var payload;
      payload = portsPayload(name, graph);
      if (!context) {
        return this.sendAll('ports', payload);
      } else {
        return this.send('ports', payload, context);
      }
    };

    RuntimeProtocol.prototype.setMainGraph = function(id) {
      return this.mainGraph = id;
    };

    RuntimeProtocol.prototype.subscribeExportedPorts = function(name, graph, add) {
      var d, dependencies, i, j, len, len1, results, sendExportedPorts;
      sendExportedPorts = (function(_this) {
        return function() {
          return _this.sendPorts(name, graph);
        };
      })(this);
      dependencies = ['addInport', 'addOutport', 'removeInport', 'removeOutport'];
      for (i = 0, len = dependencies.length; i < len; i++) {
        d = dependencies[i];
        graph.removeListener(d, sendExportedPorts);
      }
      if (add) {
        results = [];
        for (j = 0, len1 = dependencies.length; j < len1; j++) {
          d = dependencies[j];
          results.push(graph.on(d, sendExportedPorts));
        }
        return results;
      }
    };

    RuntimeProtocol.prototype.subscribeOutPorts = function(name, network, add) {
      var graph, portAdded, portRemoved;
      portRemoved = (function(_this) {
        return function() {
          return _this.subscribeOutdata(name, network, false);
        };
      })(this);
      portAdded = (function(_this) {
        return function() {
          return _this.subscribeOutdata(name, network, true);
        };
      })(this);
      graph = network.graph;
      graph.removeListener('addOutport', portAdded);
      graph.removeListener('removeOutport', portRemoved);
      if (add) {
        graph.on('addOutport', portAdded);
        return graph.on('removeOutport', portRemoved);
      }
    };

    RuntimeProtocol.prototype.subscribeOutdata = function(graphName, network, add) {
      var event, events, graphSockets, i, len, pub, socket;
      events = ['data', 'begingroup', 'endgroup', 'connect', 'disconnect'];
      if (!this.outputSockets[graphName]) {
        this.outputSockets[graphName] = {};
      }
      graphSockets = this.outputSockets[graphName];
      for (pub in graphSockets) {
        socket = graphSockets[pub];
        for (i = 0, len = events.length; i < len; i++) {
          event = events[i];
          socket.removeAllListeners(event);
        }
      }
      graphSockets = {};
      if (!add) {
        return;
      }
      return Object.keys(network.graph.outports).forEach((function(_this) {
        return function(pub) {
          var component, internal, j, len1, results, sendFunc;
          internal = network.graph.outports[pub];
          socket = noflo.internalSocket.createSocket();
          graphSockets[pub] = socket;
          component = network.processes[internal.process].component;
          component.outPorts[internal.port].attach(socket);
          sendFunc = function(event) {
            return function(payload) {
              return _this.sendAll('packet', {
                port: pub,
                event: event,
                graph: graphName,
                payload: payload
              });
            };
          };
          results = [];
          for (j = 0, len1 = events.length; j < len1; j++) {
            event = events[j];
            results.push(socket.on(event, sendFunc(event)));
          }
          return results;
        };
      })(this));
    };

    RuntimeProtocol.prototype.receivePacket = function(payload, context) {
      var component, graph, internal, network, ref;
      graph = this.transport.graph.graphs[payload.graph];
      network = this.transport.network.networks[payload.graph];
      if (!network) {
        return this.sendError("Cannot find network for graph " + payload.graph, context);
      }
      internal = graph.inports[payload.port];
      component = (ref = network.network.getNode(internal != null ? internal.process : void 0)) != null ? ref.component : void 0;
      if (!(internal && component)) {
        return this.sendError("Cannot find internal port for " + payload.port, context);
      }
      return sendToInport(component, internal.port, payload.event, payload.payload);
    };

    return RuntimeProtocol;

  })();

  module.exports = RuntimeProtocol;

}).call(this);
