(function() {
  var ComponentProtocol, _, noflo;

  noflo = require('noflo');

  _ = require('underscore');

  ComponentProtocol = (function() {
    ComponentProtocol.prototype.loaders = {};

    function ComponentProtocol(transport) {
      this.transport = transport;
    }

    ComponentProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('component', topic, payload, context);
    };

    ComponentProtocol.prototype.receive = function(topic, payload, context) {
      if (!this.transport.canDo('protocol:component', payload.secret)) {
        this.send('error', new Error(topic + " not permitted"), context);
        return;
      }
      if (topic === 'source' && !this.transport.canDo('component:setsource', payload.secret)) {
        this.send('error', new Error(topic + " not permitted"), context);
        return;
      }
      if (topic === 'getsource' && !this.transport.canDo('component:getsource', payload.secret)) {
        this.send('error', new Error(topic + " not permitted"), context);
        return;
      }
      switch (topic) {
        case 'list':
          return this.listComponents(payload, context);
        case 'getsource':
          return this.getSource(payload, context);
        case 'source':
          return this.setSource(payload, context);
      }
    };

    ComponentProtocol.prototype.getLoader = function(baseDir, options) {
      if (options == null) {
        options = {};
      }
      if (!this.loaders[baseDir]) {
        this.loaders[baseDir] = new noflo.ComponentLoader(baseDir, options);
      }
      return this.loaders[baseDir];
    };

    ComponentProtocol.prototype.listComponents = function(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir, this.transport.options);
      return loader.listComponents((function(_this) {
        return function(err, components) {
          var componentNames, processed;
          if (err) {
            _this.send('error', err, context);
            return;
          }
          componentNames = Object.keys(components);
          processed = 0;
          return componentNames.forEach(function(component) {
            return _this.processComponent(loader, component, context, function(err) {
              processed++;
              if (processed < componentNames.length) {
                return;
              }
              return _this.send('componentsready', processed, context);
            });
          });
        };
      })(this));
    };

    ComponentProtocol.prototype.getSource = function(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir, this.transport.options);
      return loader.getSource(payload.name, (function(_this) {
        return function(err, component) {
          var graph, nameParts;
          if (err) {
            graph = _this.transport.graph.graphs[payload.name];
            if (graph == null) {
              _this.send('error', err, context);
              return;
            }
            nameParts = payload.name.split('/');
            return _this.send('source', {
              name: nameParts[1],
              library: nameParts[0],
              code: JSON.stringify(graph.toJSON()),
              language: 'json'
            }, context);
          } else {
            return _this.send('source', component, context);
          }
        };
      })(this));
    };

    ComponentProtocol.prototype.setSource = function(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir, this.transport.options);
      return loader.setSource(payload.library, payload.name, payload.code, payload.language, (function(_this) {
        return function(err) {
          if (err) {
            _this.send('error', err, context);
            return;
          }
          return _this.processComponent(loader, loader.normalizeName(payload.library, payload.name), context);
        };
      })(this));
    };

    ComponentProtocol.prototype.processComponent = function(loader, component, context, callback) {
      if (!callback) {
        callback = function() {};
      }
      return loader.load(component, (function(_this) {
        return function(err, instance) {
          if (!instance) {
            if (err instanceof Error) {
              _this.send('error', err, context);
              return callback(err);
            }
            instance = err;
          }
          if (!instance.isReady()) {
            instance.once('ready', function() {
              _this.sendComponent(component, instance, context);
              return callback(null);
            });
            return;
          }
          _this.sendComponent(component, instance, context);
          return callback(null);
        };
      })(this), true);
    };

    ComponentProtocol.prototype.sendComponent = function(component, instance, context) {
      var icon, inPorts, outPorts, port, portName, ref, ref1;
      inPorts = [];
      outPorts = [];
      ref = instance.inPorts;
      for (portName in ref) {
        port = ref[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        inPorts.push({
          id: portName,
          type: port.getDataType ? port.getDataType() : void 0,
          required: port.isRequired ? port.isRequired() : void 0,
          addressable: port.isAddressable ? port.isAddressable() : void 0,
          description: port.getDescription ? port.getDescription() : void 0,
          values: port.options && port.options.values ? port.options.values : void 0,
          "default": port.options && port.options["default"] ? port.options["default"] : void 0
        });
      }
      ref1 = instance.outPorts;
      for (portName in ref1) {
        port = ref1[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        outPorts.push({
          id: portName,
          type: port.getDataType ? port.getDataType() : void 0,
          required: port.isRequired ? port.isRequired() : void 0,
          addressable: port.isAddressable ? port.isAddressable() : void 0,
          description: port.getDescription ? port.getDescription() : void 0
        });
      }
      icon = instance.getIcon ? instance.getIcon() : 'blank';
      return this.send('component', {
        name: component,
        description: instance.description,
        subgraph: instance.isSubgraph(),
        icon: icon,
        inPorts: inPorts,
        outPorts: outPorts
      }, context);
    };

    ComponentProtocol.prototype.registerGraph = function(id, graph, context) {
      var loader, send, sender;
      sender = (function(_this) {
        return function() {
          return _this.processComponent(loader, id, context);
        };
      })(this);
      send = _.debounce(sender, 10);
      loader = this.getLoader(graph.baseDir, this.transport.options);
      loader.listComponents((function(_this) {
        return function(err, components) {
          if (err) {
            _this.send('error', err, context);
            return;
          }
          loader.registerComponent('', id, graph);
          return send();
        };
      })(this));
      graph.on('addNode', send);
      graph.on('removeNode', send);
      graph.on('renameNode', send);
      graph.on('addEdge', send);
      graph.on('removeEdge', send);
      graph.on('addInitial', send);
      graph.on('removeInitial', send);
      graph.on('addInport', send);
      graph.on('removeInport', send);
      graph.on('renameInport', send);
      graph.on('addOutport', send);
      graph.on('removeOutport', send);
      return graph.on('renameOutport', send);
    };

    return ComponentProtocol;

  })();

  module.exports = ComponentProtocol;

}).call(this);
