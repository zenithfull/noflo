(function() {
  var EventEmitter, NetworkProtocol, getConnectionSignature, getEdgeSignature, getPortSignature, getSocketSignature, networkIsRunning, noflo, prepareSocketEvent,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  noflo = require('noflo');

  EventEmitter = require('events').EventEmitter;

  prepareSocketEvent = function(event, req) {
    var payload, ref;
    payload = {
      id: event.id,
      graph: req.graph
    };
    if (event.socket.from) {
      payload.src = {
        node: event.socket.from.process.id,
        port: event.socket.from.port
      };
    }
    if (event.socket.to) {
      payload.tgt = {
        node: event.socket.to.process.id,
        port: event.socket.to.port
      };
    }
    if (event.subgraph) {
      payload.subgraph = event.subgraph;
    }
    if (event.group) {
      payload.group = event.group;
    }
    if (event.data) {
      if (!noflo.isBrowser()) {
        if (Buffer.isBuffer(event.data)) {
          event.data = event.data.slice(0, 20);
        }
      }
      if (event.data.toJSON) {
        payload.data = event.data.toJSON();
      }
      if (event.data.toString) {
        payload.data = event.data.toString();
        if (payload.data === '[object Object]') {
          try {
            payload.data = JSON.parse(JSON.stringify(event.data));
          } catch (undefined) {}
        }
      } else {
        payload.data = event.data;
      }
      if ((ref = event.metadata) != null ? ref.secure : void 0) {
        payload.data = 'DATA';
      }
    }
    if (event.subgraph) {
      payload.subgraph = event.subgraph;
    }
    return payload;
  };

  getPortSignature = function(item) {
    if (!item) {
      return '';
    }
    return item.process + '(' + item.port + ')';
  };

  getEdgeSignature = function(edge) {
    return getPortSignature(edge.src) + ' -> ' + getPortSignature(edge.tgt);
  };

  getConnectionSignature = function(connection) {
    if (!connection) {
      return '';
    }
    return connection.process.id + '(' + connection.port + ')';
  };

  getSocketSignature = function(socket) {
    return getConnectionSignature(socket.from) + ' -> ' + getConnectionSignature(socket.to);
  };

  networkIsRunning = function(net) {
    var isRunning;
    if (net.isRunning) {
      isRunning = net.isRunning();
    } else {
      isRunning = net.isStarted() && net.connectionCount > 0;
    }
    return isRunning;
  };

  NetworkProtocol = (function(superClass) {
    extend(NetworkProtocol, superClass);

    function NetworkProtocol(transport) {
      this.transport = transport;
      this.networks = {};
    }

    NetworkProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('network', topic, payload, context);
    };

    NetworkProtocol.prototype.sendAll = function(topic, payload) {
      return this.transport.sendAll('network', topic, payload);
    };

    NetworkProtocol.prototype.receive = function(topic, payload, context) {
      var graph;
      if (!this.transport.canDo('protocol:network', payload.secret)) {
        this.send('error', new Error(topic + " not permitted"), context);
        return;
      }
      if (topic !== 'list') {
        graph = this.resolveGraph(payload, context);
        if (!graph) {
          return;
        }
      }
      switch (topic) {
        case 'start':
          return this.startNetwork(graph, payload, context);
        case 'stop':
          return this.stopNetwork(graph, payload, context);
        case 'edges':
          return this.updateEdgesFilter(graph, payload, context);
        case 'debug':
          return this.debugNetwork(graph, payload, context);
        case 'getstatus':
          return this.getStatus(graph, payload, context);
      }
    };

    NetworkProtocol.prototype.resolveGraph = function(payload, context) {
      if (!payload.graph) {
        this.send('error', new Error('No graph specified'), context);
        return;
      }
      if (!this.transport.graph.graphs[payload.graph]) {
        this.send('error', new Error('Requested graph not found'), context);
        return;
      }
      return this.transport.graph.graphs[payload.graph];
    };

    NetworkProtocol.prototype.updateEdgesFilter = function(graph, payload, context) {
      var edge, j, len, network, ref, results, signature;
      network = this.networks[payload.graph];
      if (network) {
        network.filters = {};
      } else {
        network = {
          network: null,
          filters: {}
        };
        this.networks[payload.graph] = network;
      }
      ref = payload.edges;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        signature = getEdgeSignature(edge);
        results.push(network.filters[signature] = true);
      }
      return results;
    };

    NetworkProtocol.prototype.eventFiltered = function(graph, event) {
      var sign;
      if (!this.transport.options.filterData) {
        return true;
      }
      sign = getSocketSignature(event.socket);
      return this.networks[graph].filters[sign];
    };

    NetworkProtocol.prototype.initNetwork = function(graph, payload, context, callback) {
      var network, opts;
      if (this.networks[payload.graph] && this.networks[payload.graph].network) {
        network = this.networks[payload.graph].network;
        network.stop();
        delete this.networks[payload.graph];
        this.emit('removenetwork', network, payload.graph, this.networks);
      }
      graph.componentLoader = this.transport.component.getLoader(graph.baseDir, this.transport.options);
      opts = JSON.parse(JSON.stringify(this.transport.options));
      opts.delay = true;
      return noflo.createNetwork(graph, (function(_this) {
        return function(err, network) {
          if (err) {
            return callback(err);
          }
          if (_this.networks[payload.graph] && _this.networks[payload.graph].network) {
            _this.networks[payload.graph].network = network;
          } else {
            _this.networks[payload.graph] = {
              network: network,
              filters: {}
            };
          }
          _this.emit('addnetwork', network, payload.graph, _this.networks);
          _this.subscribeNetwork(network, payload, context);
          return network.connect(callback);
        };
      })(this), opts);
    };

    NetworkProtocol.prototype.subscribeNetwork = function(network, payload, context) {
      network.on('start', (function(_this) {
        return function(event) {
          return _this.sendAll('started', {
            time: event.start,
            graph: payload.graph,
            running: true,
            started: network.isStarted()
          }, context);
        };
      })(this));
      network.on('end', (function(_this) {
        return function(event) {
          return _this.sendAll('stopped', {
            time: new Date,
            uptime: event.uptime,
            graph: payload.graph,
            running: false,
            started: network.isStarted()
          }, context);
        };
      })(this));
      network.on('icon', (function(_this) {
        return function(event) {
          event.graph = payload.graph;
          return _this.sendAll('icon', event, context);
        };
      })(this));
      network.on('connect', (function(_this) {
        return function(event) {
          return _this.sendAll('connect', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('begingroup', (function(_this) {
        return function(event) {
          return _this.sendAll('begingroup', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('data', (function(_this) {
        return function(event) {
          if (!_this.eventFiltered(payload.graph, event)) {
            return;
          }
          return _this.sendAll('data', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('endgroup', (function(_this) {
        return function(event) {
          return _this.sendAll('endgroup', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('disconnect', (function(_this) {
        return function(event) {
          return _this.sendAll('disconnect', prepareSocketEvent(event, payload), context);
        };
      })(this));
      return network.on('process-error', (function(_this) {
        return function(event) {
          var bt, error, i, j, ref;
          error = event.error.message;
          if (event.error.stack) {
            bt = event.error.stack.split('\n');
            for (i = j = 0, ref = Math.min(bt.length, 3); 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
              error += "\n" + bt[i];
            }
          }
          return _this.sendAll('processerror', {
            id: event.id,
            error: error,
            graph: payload.graph
          }, context);
        };
      })(this));
    };

    NetworkProtocol.prototype.startNetwork = function(graph, payload, context) {
      var doStart, network;
      doStart = (function(_this) {
        return function(net) {
          return net.start(function(err) {
            if (err) {
              return _this.send('error', err, content);
            }
            if (net.isStarted()) {
              return _this.sendAll('started', {
                time: new Date,
                graph: payload.graph,
                running: networkIsRunning(net),
                started: true
              }, context);
            } else {
              return _this.sendAll('stopped', {
                time: new Date,
                graph: payload.graph,
                running: networkIsRunning(net),
                started: false
              }, context);
            }
          });
        };
      })(this);
      network = this.networks[payload.graph];
      if (network && network.network) {
        doStart(network.network);
        return;
      }
      return this.initNetwork(graph, payload, context, (function(_this) {
        return function(err) {
          if (err) {
            return _this.send('error', err, context);
          }
          network = _this.networks[payload.graph];
          return doStart(network.network);
        };
      })(this));
    };

    NetworkProtocol.prototype.stopNetwork = function(graph, payload, context) {
      var net;
      if (!this.networks[payload.graph]) {
        return;
      }
      net = this.networks[payload.graph].network;
      if (!net) {
        return;
      }
      if (net.isStarted()) {
        this.networks[payload.graph].network.stop();
        return;
      }
      return this.send('stopped', {
        time: new Date,
        graph: payload.graph,
        running: networkIsRunning(net),
        started: false
      }, context);
    };

    NetworkProtocol.prototype.debugNetwork = function(graph, payload, context) {
      var net;
      if (!this.networks[payload.graph]) {
        return;
      }
      net = this.networks[payload.graph].network;
      if (!net) {
        return;
      }
      if (net.setDebug != null) {
        return net.setDebug(payload.enable);
      } else {
        return console.log('Warning: Network.setDebug not supported. Update to newer NoFlo');
      }
    };

    NetworkProtocol.prototype.getStatus = function(graph, payload, context) {
      var net;
      if (!this.networks[payload.graph]) {
        return;
      }
      net = this.networks[payload.graph].network;
      if (!net) {
        return;
      }
      return this.send('status', {
        graph: payload.graph,
        running: networkIsRunning(net),
        started: net.isStarted()
      }, context);
    };

    return NetworkProtocol;

  })(EventEmitter);

  module.exports = NetworkProtocol;

}).call(this);
