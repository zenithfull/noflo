var chai, direct, noflo;

noflo = require('noflo');

if (noflo.isBrowser()) {
  direct = require('noflo-runtime-base').direct;
} else {
  if (!chai) {
    chai = require('chai');
  }
  direct = require('../src/direct');
}

describe('Runtime protocol', function() {
  var client, runtime;
  runtime = null;
  client = null;
  beforeEach(function() {
    runtime = new direct.Runtime;
    client = new direct.Client(runtime);
    return client.connect();
  });
  afterEach(function() {
    client.disconnect();
    client = null;
    return runtime = null;
  });
  return describe('sending runtime:getruntime', function() {
    it('should respond with runtime:runtime for unauthorized user', function(done) {
      client.once('message', function(msg) {
        chai.expect(msg.protocol).to.equal('runtime');
        chai.expect(msg.command).to.equal('runtime');
        chai.expect(msg.payload.type).to.have.string('noflo');
        chai.expect(msg.payload.capabilities).to.eql([]);
        chai.expect(msg.payload.allCapabilities).to.include('protocol:graph');
        return done();
      });
      return client.send('runtime', 'getruntime', null);
    });
    return it('should respond with runtime:runtime for authorized user', function(done) {
      client.disconnect();
      runtime = new direct.Runtime({
        permissions: {
          'super-secret': ['protocol:graph', 'protocol:component', 'unknown:capability']
        }
      });
      client = new direct.Client(runtime);
      client.connect();
      client.once('message', function(msg) {
        chai.expect(msg.protocol).to.equal('runtime');
        chai.expect(msg.command).to.equal('runtime');
        chai.expect(msg.payload.type).to.have.string('noflo');
        chai.expect(msg.payload.capabilities).to.eql(['protocol:graph', 'protocol:component']);
        chai.expect(msg.payload.allCapabilities).to.include('protocol:graph');
        return done();
      });
      return client.send('runtime', 'getruntime', {
        secret: 'super-secret'
      });
    });
  });
});
