var chai, direct, noflo;

noflo = require('noflo');

if (noflo.isBrowser()) {
  direct = require('noflo-runtime-base').direct;
} else {
  if (!chai) {
    chai = require('chai');
  }
  direct = require('../src/direct');
}

describe('Graph protocol', function() {
  var client, client2, runtime;
  runtime = null;
  client = null;
  client2 = null;
  beforeEach(function() {
    runtime = new direct.Runtime({
      permissions: {
        foo: ['protocol:graph']
      }
    });
    client = new direct.Client(runtime);
    client.connect();
    client2 = new direct.Client(runtime);
    return client2.connect();
  });
  afterEach(function() {
    client.disconnect();
    client = null;
    client2.disconnect();
    client2 = null;
    return runtime = null;
  });
  describe('sending graph:clear', function() {
    it('should fail without proper authentication', function(done) {
      var payload;
      payload = {
        id: 'mygraph',
        main: true
      };
      client.once('message', function(msg) {
        chai.expect(msg.protocol).to.equal('graph');
        chai.expect(msg.command).to.equal('error');
        return done();
      });
      return client.send('graph', 'clear', payload);
    });
    it('should respond with graph:clear', function(done) {
      var payload;
      payload = {
        id: 'mygraph',
        main: true,
        secret: 'foo'
      };
      client.once('message', function(msg) {
        chai.expect(msg.protocol).to.equal('graph');
        chai.expect(msg.command).to.equal('clear');
        chai.expect(msg.payload).to.include.keys('id');
        chai.expect(msg.payload.id).to.equal(payload.id);
        return done();
      });
      return client.send('graph', 'clear', payload);
    });
    return it('should send to all clients', function(done) {
      var payload;
      payload = {
        id: 'mygraph',
        main: true,
        secret: 'foo'
      };
      client2.once('message', function(msg) {
        chai.expect(msg.protocol).to.equal('graph');
        chai.expect(msg.command).to.equal('clear');
        chai.expect(msg.payload).to.include.keys('id');
        chai.expect(msg.payload.id).to.equal(payload.id);
        return done();
      });
      return client.send('graph', 'clear', payload);
    });
  });
  return describe('sending graph:addnode', function() {
    var authenticatedPayload, checkAddNode, graph, payload;
    graph = 'graphwithnodes';
    payload = {
      id: 'node1',
      component: 'Component1',
      graph: graph,
      metadata: {}
    };
    authenticatedPayload = JSON.parse(JSON.stringify(payload));
    authenticatedPayload.secret = 'foo';
    checkAddNode = function(msg, done) {
      if (msg.command !== 'addnode') {
        return;
      }
      chai.expect(msg.protocol).to.equal('graph');
      chai.expect(msg.command).to.equal('addnode');
      chai.expect(msg.payload).to.deep.equal(payload);
      return done();
    };
    it('should respond with graph:addnode', function(done) {
      client.on('message', function(msg) {
        return checkAddNode(msg, done);
      });
      client.send('graph', 'clear', {
        id: graph,
        main: true,
        secret: 'foo'
      });
      return client.send('graph', 'addnode', authenticatedPayload);
    });
    return it('should send to all clients', function(done) {
      client2.on('message', function(msg) {
        return checkAddNode(msg, done);
      });
      client.send('graph', 'clear', {
        id: graph,
        main: true,
        secret: 'foo'
      });
      return client.send('graph', 'addnode', authenticatedPayload);
    });
  });
});
